Index: app/dao/stats.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># app/dao/stats.py\r\n\r\nfrom app.config.dbconfig import pg_config\r\nimport psycopg2\r\nfrom typing import List, Dict, Optional\r\n\r\n\r\nclass StatsDAO:\r\n    def __init__(self):\r\n        connection_url = \"dbname=%s user=%s password=%s host=%s port=%s\" % (\r\n            pg_config['dbname'],\r\n            pg_config['user'],\r\n            pg_config['passwd'],\r\n            pg_config['host'],\r\n            pg_config['port']\r\n        )\r\n        self.conn = psycopg2.connect(connection_url)\r\n\r\n    # ------------------------------------------------------------------\r\n    # 1. Top classes by average meeting duration\r\n    # ------------------------------------------------------------------\r\n    def top_classes_by_avg_duration(\r\n        self,\r\n        year: Optional[str] = None,\r\n        semester: Optional[str] = None,\r\n        limit: int = 1\r\n    ) -> List[Dict]:\r\n        limit = min(max(limit, 1), 10)\r\n\r\n        query = \"\"\"\r\n            SELECT\r\n                c.cid,\r\n                c.ccode,\r\n                ROUND(AVG(EXTRACT(EPOCH FROM (m.endtime - m.starttime)) / 60), 1) AS avg_minutes\r\n            FROM class c\r\n            JOIN section s ON s.cid = c.cid\r\n            JOIN meeting m ON s.mid = m.mid\r\n            WHERE 1=1\r\n        \"\"\"\r\n        params = []\r\n\r\n        if year:\r\n            query += \" AND s.years = %s\"\r\n            params.append(year)\r\n        if semester:\r\n            query += \" AND s.semester = %s\"\r\n            params.append(semester)\r\n\r\n        query += \"\"\"\r\n            GROUP BY c.cid, c.ccode\r\n            HAVING COUNT(m.mid) > 0\r\n            ORDER BY avg_minutes DESC\r\n            LIMIT %s\r\n        \"\"\"\r\n        params.append(limit)\r\n\r\n        cursor = self.conn.cursor()\r\n        cursor.execute(query, params)\r\n        result = []\r\n        for row in cursor:\r\n            result.append({\r\n                \"cid\": row[0],\r\n                \"fullcode\": row[1],\r\n                \"avg_minutes\": float(row[2])\r\n            })\r\n        cursor.close()\r\n        return result\r\n\r\n    # ------------------------------------------------------------------\r\n    # 2. Classes without prerequisites\r\n    # ------------------------------------------------------------------\r\n    def classes_without_prereqs(self) -> List[Dict]:\r\n        query = \"\"\"\r\n            SELECT c.cid, c.ccode\r\n            FROM class c\r\n            LEFT JOIN requisite r ON r.classid = c.cid\r\n            WHERE r.classid IS NULL\r\n            ORDER BY c.ccode\r\n        \"\"\"\r\n        cursor = self.conn.cursor()\r\n        cursor.execute(query)\r\n        result = []\r\n        for row in cursor:\r\n            result.append({\r\n                \"cid\": row[0],\r\n                \"fullcode\": row[1]\r\n            })\r\n        cursor.close()\r\n        return result\r\n        # ------------------------------------------------------------------\r\n        # 3. Top rooms by average utilization (capacity proxy)\r\n        # ------------------------------------------------------------------\r\n\r\n    def top_rooms_by_utilization(\r\n            self,\r\n            year: Optional[str] = None,\r\n            semester: Optional[str] = None,\r\n            limit: Optional[int] = None\r\n    ) -> List[Dict]:\r\n        \"\"\"\r\n        utilization = AVG(section.capacity / room.capacity)\r\n        Optional filters: year, semester\r\n        Optional limit: if provided\r\n        \"\"\"\r\n\r\n        query = \"\"\"\r\n              SELECT\r\n                  r.rid,\r\n                  r.building,\r\n                  r.room_number,\r\n                  ROUND(\r\n                      AVG(\r\n                          CAST(s.capacity AS FLOAT)\r\n                          / NULLIF(r.capacity, 0)\r\n                      )::numeric,\r\n                      2\r\n                  ) AS utilization\r\n              FROM section s\r\n              JOIN room r ON s.roomid = r.rid\r\n              WHERE 1=1\r\n          \"\"\"\r\n        params = []\r\n\r\n        if year:\r\n            query += \" AND s.years = %s\"\r\n            params.append(year)\r\n\r\n        if semester:\r\n            query += \" AND s.semester = %s\"\r\n            params.append(semester)\r\n\r\n        query += \"\"\"\r\n              GROUP BY r.rid, r.building, r.room_number\r\n              ORDER BY utilization DESC\r\n          \"\"\"\r\n\r\n        if limit is not None:\r\n            query += \" LIMIT %s\"\r\n            params.append(limit)\r\n\r\n        cursor = self.conn.cursor()\r\n        cursor.execute(query, params)\r\n        rows = cursor.fetchall()\r\n        result = [\r\n            {\r\n                \"rid\": row[0],\r\n                \"building\": row[1],\r\n                \"room_number\": row[2],\r\n                \"utilization\": float(row[3]) if row[3] is not None else None\r\n            }\r\n            for row in rows\r\n        ]\r\n        cursor.close()\r\n        return result\r\n\r\n        # ------------------------------------------------------------------\r\n        # 4. Multi-room classes (distinct rooms per class)\r\n        # ------------------------------------------------------------------\r\n        # ------------------------------------------------------------------\r\n        # 4. Multi-room classes (distinct rooms per class)\r\n        # ------------------------------------------------------------------\r\n\r\n    def multi_room_classes(\r\n            self,\r\n            year: Optional[str] = None,\r\n            semester: Optional[str] = None,\r\n            limit: Optional[int] = None,\r\n            orderby: str = \"desc\"\r\n    ) -> List[Dict]:\r\n        \"\"\"\r\n        Returns classes that use more than one distinct room.\r\n        Optional filters: year, semester.\r\n        Optional limit: if provided (no limit otherwise)\r\n        orderby: 'asc' or 'desc' on distinct_rooms.\r\n        \"\"\"\r\n\r\n        order_dir = \"ASC\" if (orderby and orderby.lower() == \"asc\") else \"DESC\"\r\n\r\n        query = \"\"\"\r\n              SELECT\r\n                  c.cid,\r\n                  c.ccode,\r\n                  COUNT(DISTINCT s.roomid) AS distinct_rooms\r\n              FROM class c\r\n              JOIN section s ON s.cid = c.cid\r\n              WHERE 1=1\r\n          \"\"\"\r\n        params = []\r\n\r\n        if year:\r\n            query += \" AND s.years = %s\"\r\n            params.append(year)\r\n\r\n        if semester:\r\n            query += \" AND s.semester = %s\"\r\n            params.append(semester)\r\n\r\n        query += f\"\"\"\r\n              GROUP BY c.cid, c.ccode\r\n              HAVING COUNT(DISTINCT s.roomid) > 1\r\n              ORDER BY distinct_rooms {order_dir}, c.ccode\r\n          \"\"\"\r\n\r\n        if limit is not None:\r\n            query += \" LIMIT %s\"\r\n            params.append(limit)\r\n\r\n        cursor = self.conn.cursor()\r\n        cursor.execute(query, params)\r\n        rows = cursor.fetchall()  # ✅ This gets all rows\r\n        cursor.close()\r\n\r\n        result = [\r\n            {\r\n                \"cid\": row[0],\r\n                \"fullcode\": row[1],\r\n                \"distinct_rooms\": row[2]\r\n            }\r\n            for row in rows\r\n        ]\r\n        return result\r\n\r\n        # ------------------------------------------------------------------\r\n        # 5. Top departments by sections (from class.cname)\r\n        # ------------------------------------------------------------------\r\n\r\n    def top_departments_by_sections(\r\n            self,\r\n            year: Optional[str] = None,\r\n            semester: Optional[str] = None,\r\n            limit: Optional[int] = None\r\n    ) -> List[Dict]:\r\n        \"\"\"\r\n        Returns top departments (from class.cname) by number of sections.\r\n        Optional filters: year, semester.\r\n        Optional limit: default None (no limit), capped at 5 if given.\r\n        \"\"\"\r\n\r\n        query = \"\"\"\r\n              SELECT\r\n                  c.cname AS dept_code,\r\n                  COUNT(*) AS sections\r\n              FROM class c\r\n              JOIN section s ON s.cid = c.cid\r\n              WHERE 1=1\r\n          \"\"\"\r\n        params = []\r\n\r\n        if year:\r\n            query += \" AND s.years = %s\"\r\n            params.append(year)\r\n\r\n        if semester:\r\n            query += \" AND s.semester = %s\"\r\n            params.append(semester)\r\n\r\n        query += \"\"\"\r\n              GROUP BY c.cname\r\n              ORDER BY sections DESC, dept_code\r\n          \"\"\"\r\n\r\n        # Only add LIMIT if explicitly provided\r\n        if limit is not None:\r\n            limit = min(max(limit, 1), 5)\r\n            query += \" LIMIT %s\"\r\n            params.append(limit)\r\n\r\n        cursor = self.conn.cursor()\r\n        cursor.execute(query, params)\r\n        rows = cursor.fetchall()\r\n        cursor.close()\r\n\r\n        result = [\r\n            {\r\n                \"fullcode\": row[0],\r\n                \"sections\": row[1]\r\n            }\r\n            for row in rows\r\n        ]\r\n        return result\r\n\r\n    def close(self):\r\n        if self.conn and not self.conn.closed:\r\n            self.conn.close()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/dao/stats.py b/app/dao/stats.py
--- a/app/dao/stats.py	
+++ b/app/dao/stats.py	
@@ -207,7 +207,7 @@
 
         cursor = self.conn.cursor()
         cursor.execute(query, params)
-        rows = cursor.fetchall()  # ✅ This gets all rows
+        rows = cursor.fetchall()
         cursor.close()
 
         result = [
